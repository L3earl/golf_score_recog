---
description: 데이터베이스 스키마 문서 생성 가이드라인 - 시스템의 데이터 구조 설계 및 문서화
globs: docs/database/*.sql
---

# 데이터베이스 스키마 문서 생성 가이드라인

시스템의 **데이터 구조를 설계하고 문서화**하는 가이드라인입니다.

## 🎯 데이터베이스 스키마의 목표

**이 기능을 위해 필요한 데이터를 어떤 구조로, 어떻게 저장하고 연결할 것인가?**

데이터베이스 스키마는 시스템의 **'뼈대'**를 설계합니다. 모든 데이터의 원본(Source of Truth) 구조를 정의합니다.

## 📋 핵심 포함 내용

### **1. 테이블 명 (Table Name)**
기능을 설명하는 명확한 이름을 사용합니다.

**명명 규칙:**
- **snake_case** 사용 (e.g., `chat_messages`, `user_profiles`)
- **복수형** 사용 (e.g., `users`, `messages`)
- **의미 있는 이름** 사용 (e.g., `user_sessions` vs `sessions`)

**예시:**
```sql
-- ✅ 좋은 예시
CREATE TABLE users (
    -- 사용자 정보
);

CREATE TABLE chat_messages (
    -- 채팅 메시지 정보
);

CREATE TABLE user_sessions (
    -- 사용자 세션 정보
);

-- ❌ 나쁜 예시
CREATE TABLE data (
    -- 모호한 이름
);

CREATE TABLE tbl1 (
    -- 의미 없는 이름
);
```

### **2. 컬럼 정보 (Column Information)**
각 테이블에 들어갈 데이터 항목들을 상세히 정의합니다.

#### **컬럼 명 (Column Name)**
- **snake_case** 사용 (e.g., `user_id`, `created_at`)
- **의미 있는 이름** 사용 (e.g., `email_address` vs `email`)
- **일관된 네이밍** 사용 (e.g., 모든 테이블에서 `created_at`, `updated_at`)

#### **데이터 타입 (Data Type)**
- **PostgreSQL 권장 타입** 사용
- **정확한 타입** 선택 (e.g., `VARCHAR(255)` vs `TEXT`)

**주요 데이터 타입:**
```sql
-- 식별자
UUID                    -- 고유 식별자
SERIAL                  -- 자동 증가 정수
BIGSERIAL              -- 큰 자동 증가 정수

-- 문자열
VARCHAR(n)             -- 가변 길이 문자열
TEXT                   -- 긴 텍스트
CHAR(n)                -- 고정 길이 문자열

-- 숫자
INTEGER                -- 정수
BIGINT                 -- 큰 정수
DECIMAL(p,s)           -- 소수점 숫자
REAL                   -- 실수

-- 날짜/시간
TIMESTAMP              -- 날짜와 시간
TIMESTAMPTZ            -- 타임존 포함 날짜와 시간
DATE                   -- 날짜만
TIME                   -- 시간만

-- 불린
BOOLEAN                -- 참/거짓

-- JSON
JSON                   -- JSON 데이터
JSONB                  -- 바이너리 JSON (인덱스 가능)

-- 배열
TEXT[]                 -- 텍스트 배열
INTEGER[]              -- 정수 배열
```

#### **제약 조건 (Constraints)**
데이터 무결성을 보장하기 위한 제약 조건을 정의합니다.

**주요 제약 조건:**
```sql
-- Primary Key (고유키)
PRIMARY KEY (id)
PRIMARY KEY (user_id, session_id)  -- 복합 키

-- Foreign Key (외래키)
FOREIGN KEY (user_id) REFERENCES users(id)
FOREIGN KEY (category_id) REFERENCES categories(id) ON DELETE CASCADE

-- Not Null (필수값)
NOT NULL

-- Unique (유일값)
UNIQUE (email)
UNIQUE (username)

-- Default (기본값)
DEFAULT CURRENT_TIMESTAMP
DEFAULT false
DEFAULT 'active'

-- Check (조건 검사)
CHECK (age >= 0 AND age <= 150)
CHECK (status IN ('active', 'inactive', 'pending'))
```

### **3. 관계 (Relationships)**
테이블 간의 연결 관계를 명시합니다.

#### **관계 유형**
- **One-to-One (1:1)**: 한 사용자당 하나의 프로필
- **One-to-Many (1:N)**: 한 사용자당 여러 메시지
- **Many-to-Many (N:N)**: 여러 사용자가 여러 그룹에 속함

#### **관계 표현 방법**
```sql
-- One-to-Many 관계
CREATE TABLE users (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    email VARCHAR(255) UNIQUE NOT NULL,
    created_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP
);

CREATE TABLE messages (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID NOT NULL,
    content TEXT NOT NULL,
    created_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP,
    
    FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE
);

-- Many-to-Many 관계 (중간 테이블)
CREATE TABLE user_groups (
    user_id UUID NOT NULL,
    group_id UUID NOT NULL,
    joined_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP,
    
    PRIMARY KEY (user_id, group_id),
    FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE,
    FOREIGN KEY (group_id) REFERENCES groups(id) ON DELETE CASCADE
);
```

### **4. 인덱스 (Indexes)**
데이터 검색 속도를 높이기 위한 인덱스를 정의합니다.

#### **인덱스 유형**
```sql
-- 기본 인덱스
CREATE INDEX idx_users_email ON users(email);

-- 복합 인덱스
CREATE INDEX idx_messages_user_created ON messages(user_id, created_at);

-- 부분 인덱스
CREATE INDEX idx_active_users ON users(email) WHERE status = 'active';

-- 고유 인덱스
CREATE UNIQUE INDEX idx_users_username ON users(username);

-- 텍스트 검색 인덱스
CREATE INDEX idx_messages_content_search ON messages USING gin(to_tsvector('english', content));
```

#### **인덱스 전략**
- **자주 조회되는 컬럼**에 인덱스 생성
- **WHERE 절**에서 자주 사용되는 컬럼
- **JOIN 조건**에서 사용되는 컬럼
- **ORDER BY**에서 자주 사용되는 컬럼

## 🏗️ 스키마 설계 단계

### **1단계: 요구사항 분석**
- 기능별로 필요한 데이터 식별
- UI/UX 디자인에서 표시되는 모든 정보 파악
- 데이터 간의 관계 분석

### **2단계: 테이블 설계**
- 각 엔티티별로 테이블 설계
- 컬럼명, 데이터 타입, 제약 조건 정의
- 정규화 고려 (1NF, 2NF, 3NF)

### **3단계: 관계 설계**
- 테이블 간의 관계 정의
- Foreign Key 제약 조건 설정
- 참조 무결성 규칙 정의

### **4단계: 인덱스 설계**
- 쿼리 패턴 분석
- 성능 최적화를 위한 인덱스 설계
- 인덱스 오버헤드 고려

### **5단계: 문서화**
- 스키마 다이어그램 생성 (ERD)
- 테이블별 상세 문서 작성
- 관계 및 제약 조건 문서화

## 📝 스키마 문서 템플릿

### **테이블 문서 템플릿**
```markdown
# users 테이블

## 개요
사용자 기본 정보를 저장하는 테이블입니다.

## 컬럼 정보
| 컬럼명 | 데이터 타입 | 제약 조건 | 설명 |
|--------|-------------|-----------|------|
| id | UUID | PRIMARY KEY, DEFAULT gen_random_uuid() | 사용자 고유 식별자 |
| email | VARCHAR(255) | UNIQUE, NOT NULL | 이메일 주소 |
| password_hash | VARCHAR(255) | NOT NULL | 암호화된 비밀번호 |
| username | VARCHAR(50) | UNIQUE, NOT NULL | 사용자명 |
| status | VARCHAR(20) | DEFAULT 'active', CHECK | 사용자 상태 |
| created_at | TIMESTAMPTZ | DEFAULT CURRENT_TIMESTAMP | 생성일시 |
| updated_at | TIMESTAMPTZ | DEFAULT CURRENT_TIMESTAMP | 수정일시 |

## 인덱스
- `idx_users_email`: email 컬럼 인덱스
- `idx_users_username`: username 컬럼 인덱스
- `idx_users_status`: status 컬럼 인덱스

## 관계
- **One-to-Many**: users → messages (user_id)
- **One-to-Many**: users → user_sessions (user_id)
- **Many-to-Many**: users ↔ groups (user_groups 테이블)

## 제약 조건
- `status`는 'active', 'inactive', 'pending' 중 하나여야 함
- `email`은 유일해야 함
- `username`은 유일해야 함
```

### **ERD 문서 템플릿**
```markdown
# 데이터베이스 ERD

## 전체 구조
시스템의 모든 테이블과 관계를 보여주는 ERD입니다.

## 주요 엔티티
- **users**: 사용자 정보
- **messages**: 채팅 메시지
- **groups**: 채팅 그룹
- **user_sessions**: 사용자 세션

## 관계 설명
- users 1:N messages
- users N:N groups (user_groups)
- users 1:N user_sessions

## 다이어그램
[ERD 이미지 또는 PlantUML 코드]
```

## ✅ 스키마 설계 체크리스트

### **기능 요구사항**
- [ ] **새 테이블 필요성**: 이 기능을 위해 새로운 테이블이 필요한가? 기존 테이블에 컬럼 추가만으로 충분한가?
- [ ] **UI/UX 매핑**: UI/UX 디자인에 표시되는 모든 정보는 DB에 저장될 필드가 있는가?
- [ ] **데이터 완성도**: 필요한 모든 데이터가 포함되어 있는가?

### **데이터 무결성**
- [ ] **Primary Key**: 모든 테이블에 적절한 Primary Key가 있는가?
- [ ] **Foreign Key**: 테이블 간 관계가 올바르게 정의되어 있는가?
- [ ] **제약 조건**: 데이터 무결성을 위한 제약 조건이 적절한가?
- [ ] **참조 무결성**: 삭제/수정 시 참조 무결성이 보장되는가?

### **성능 최적화**
- [ ] **인덱스 설계**: 데이터를 빠르게 조회하려면 어떤 컬럼에 인덱스가 필요한가?
- [ ] **쿼리 최적화**: 자주 실행되는 쿼리가 효율적으로 실행될 수 있는가?
- [ ] **정규화**: 적절한 정규화 수준을 유지하고 있는가?

### **확장성**
- [ ] **확장 가능성**: 향후 기능 추가 시 스키마 확장이 용이한가?
- [ ] **마이그레이션**: 스키마 변경 시 마이그레이션 전략이 있는가?
- [ ] **버전 관리**: 스키마 변경 이력이 관리되고 있는가?

## 🔗 관련 문서와의 연계

### **API 명세서와의 연계**
- API에서 조회/저장하는 데이터가 스키마와 일치해야 함
- 요청/응답 데이터 구조가 DB 컬럼과 일치해야 함

### **시퀀스 다이어그램과의 연계**
- 데이터베이스 조회/저장 작업이 실제 DB 스키마와 일치해야 함
- 테이블명, 컬럼명이 시퀀스 다이어그램과 일치해야 함

### **ERD와의 연계**
- 스키마 문서의 관계 설명이 ERD와 일치해야 함
- Foreign Key 관계가 ERD에 올바르게 표현되어야 함

## 📁 파일 구조

```
docs/
├── database/
│   ├── schema.md              # 전체 스키마 개요
│   ├── tables/
│   │   ├── users.md           # users 테이블 문서
│   │   ├── messages.md        # messages 테이블 문서
│   │   └── groups.md          # groups 테이블 문서
│   └── migrations/
│       ├── 001_create_users.sql
│       └── 002_create_messages.sql
├── erd/
│   ├── database_erd.puml      # 전체 ERD
│   └── database_erd.png       # ERD 이미지
└── sequence_dia/
    └── register.puml          # 시퀀스 다이어그램
```

## 🛠️ 도구 및 기술

### **데이터베이스 관리 도구**
- **Supabase**: PostgreSQL 기반 BaaS
- **pgAdmin**: PostgreSQL 관리 도구
- **DBeaver**: 범용 데이터베이스 도구

### **스키마 문서화 도구**
- **PlantUML**: ERD 생성
- **Mermaid**: 다이어그램 생성
- **dbdocs**: 데이터베이스 문서화

### **마이그레이션 도구**
- **Supabase CLI**: Supabase 마이그레이션
- **Alembic**: Python 마이그레이션
- **Flyway**: Java 마이그레이션

## 💡 모범 사례

### **명명 규칙**
- 테이블명은 복수형 snake_case 사용
- 컬럼명은 의미 있는 snake_case 사용
- 인덱스명은 `idx_테이블명_컬럼명` 형식 사용

### **데이터 타입 선택**
- 식별자는 UUID 사용
- 시간은 TIMESTAMPTZ 사용
- 텍스트는 적절한 길이의 VARCHAR 사용

### **성능 고려사항**
- 자주 조회되는 컬럼에 인덱스 생성
- 복합 인덱스는 쿼리 패턴에 맞게 설계
- 불필요한 인덱스는 생성하지 않음

### **보안 고려사항**
- 민감한 정보는 암호화하여 저장
- 적절한 접근 권한 설정
- 데이터 마스킹 및 익명화 고려